#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""TBD

"""
import logging
from argparse import ArgumentParser
from datetime import datetime

import boto3
import pytz


log = logging.getLogger(__name__)

emr = boto3.client('emr', region_name='us-west-2')


DEFAULT_CLUSTER_NAME = 'default'


def utcnow():
    return pytz.utc.localize(datetime.utcnow())


def create_cluster(name, **kwargs):
    resp = emr.run_job_flow(
        Name=name,
        ReleaseLabel='emr-5.7.0',
        Instances={
            'InstanceGroups': [
                {'Name': 'master',
                 'InstanceRole': 'MASTER',
                 'InstanceType': 'm1.medium',  # Use m1.large for Spark
                 'InstanceCount': 1},
                {'Name': 'core',
                 'InstanceRole': 'CORE',
                 'InstanceType': 'm1.large',
                 'InstanceCount': 1},
            ],
            'KeepJobFlowAliveWhenNoSteps': True,
        },
        VisibleToAllUsers=False,
        JobFlowRole='EMR_EC2_DefaultRole',
        ServiceRole='EMR_DefaultRole',
    )
    print(resp)


def terminate_cluster(name):
    print('TODO: Terminate cluster ' + name)


def _paginate(func, args, key):
    marker = None
    while 1:
        if marker:
            args['Marker'] = marker
        resp = func(**args)
        if key in resp:
            for item in resp[key]:
                yield item
        if 'Marker' not in resp:
            break
        marker = resp['Marker']


def get_clusters(prefix=None, states=None):
    """Gets a list of EMR clusters.

    :type prefix: :class:`str` or :obj:`None`
    :param prefix: The name prefix of EMR clusters to capture.

    :returns: The response generator of :class:`dict` items.

    """
    args = {}
    if states:
        args['ClusterStates'] = states
    for cluster in _paginate(emr.list_clusters, args, 'Clusters'):
        if not prefix or cluster['Name'].startswith(prefix):
            yield cluster


def get_step_before_idle(cluster_id):
    """Get an EMR step which finished (success or failure) before the
    cluster going idle.

    Args:
        cluster_id (str): Cluster ID.

    """
    steps = list(_paginate(emr.list_steps, {'ClusterId': cluster_id}, 'Steps'))
    for step in steps:
        state = step['Status']['State']
        if state in ('PENDING', 'RUNNING',):
            # Not idle
            return None
        if state in ('CANCEL_PENDING', 'CANCELLED'):
            # Ignore cancelled step
            continue
        if state in ('COMPLETED', 'FAILED', 'INTERRUPTED'):
            # The step at least finished with EndDateTime recorded
            break
    else:
        log.warning('No step with valid status state found!')
        return None
    return step


def get_end_timestamp_of_last_step(cluster_id):
    step = get_step_before_idle(cluster_id)
    if step is None:
        return None
    return step['Status']['Timeline']['EndDateTime']


def get_cluster_start_time(cluster):
    return cluster['Status']['Timeline']['ReadyDateTime']


def cluster_is_idle(cluster, min_idle_time=1800):
    cluster_id = cluster['Id']
    started = get_cluster_start_time(cluster)
    last_used = get_end_timestamp_of_last_step(cluster_id)
    if last_used is None:
        return False

    now = utcnow()
    idle_time = (now - last_used).total_seconds()
    log.info('Cluster %s has been idle for %.1f sec', cluster_id, idle_time)

    if idle_time < min_idle_time:
        return False
    return True


def is_close_to_cost_increase_boundary(cluster, window=300):
    now = utcnow()
    started = get_cluster_start_time(cluster)
    till_boundary = 3600 - ((now - started).total_seconds() % 3600)
    log.info('Cluster %s is %.1f sec to crossing cost increase boundary',
             cluster['Id'], till_boundary)
    return till_boundary < window


def terminate_clusters(name_prefix, now=False, min_idle_time=3600, **kwargs):
    for prefix in name_prefix:
        for cluster in get_clusters(prefix, states=['WAITING']):
            if cluster_is_idle(cluster):
                if is_close_to_cost_increase_boundary(cluster):
                    print('close to boundary')
                else:
                    print('not close to boundary')
                print(cluster)


        # if cluster_is_idling(prefix, min_idle_time=min_idle_time, terminate_now=now):
        #     terminate_cluster(prefix)


if __name__ == '__main__':
    parent = ArgumentParser(description=__doc__.strip(), add_help=False)
    parent.add_argument(
        '--logging-file', type=str,
        help='Path to log file')
    parent.add_argument(
        '--logging-level', type=str, default='WARNING',
        help='Logging level')

    p = ArgumentParser(parents=[parent])
    subparsers = p.add_subparsers(dest='action', help='Action to carry out')

    sub = subparsers.add_parser(
        'create',
        help='Create an EMR cluster')
    sub.add_argument(
        '--name', '-n', type=str, default=DEFAULT_CLUSTER_NAME,
        help='Name for the created EMR cluster')

    sub = subparsers.add_parser(
        'terminate',
        help='Terminate EMR cluster(s)')

    group = sub.add_mutually_exclusive_group(required=True)
    group.add_argument(
        '--cluster-id', nargs='+', type=str,
        help='EMR cluster ID')
    group.add_argument(
        '--name-prefix', nargs='+', type=str,
        help='EMR cluster name prefix(es) to check for termination')

    sub.add_argument(
        '--min-idle-time', type=int, default=3300,
        help='Minimum seconds of inactivity before termination (default: 3300)')
    sub.add_argument(
        '--now', action='store_true', default=False,
        help='Terminate idle clusters immediately')

    args = p.parse_args()

    try:
        action = {'create': create_cluster,
                  'terminate': terminate_clusters}[args.action]
    except KeyError:
        p.print_help()
        sys.exit(1)

    action(**vars(args))
